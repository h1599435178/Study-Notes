### 1. 小美的外卖订单

小美正在设计美团外卖的定价信息。已知外卖定价的规则如下：

1. 每道菜有折扣价和原价。折扣价不能超过原价。
2.  订单有满*x*元减*y*元的优惠。当购买的菜的价格总和不小于*x*元时，总价格可以减*y*元。“减”的价格不能超过“满”的价格。
3. 满减优惠和折扣价是互斥的，当且仅当每个菜都选择了原价才可以触发满减。
4.  系统会自动为客户计算最低价格的方案。

在设计定价时，原价、折扣价和满减的价格都必须是正实数。如果设计的定价发生问题，则会提示数据错误。
请使用等价划分法设计测试用例，来测试该系统的功能。

```
时间限制：C/C++ 1秒，其他语言2秒

空间限制：C/C++ 256M，其他语言512M
```

##### 输入描述：

```
第一行输入一个正整数，代表菜的总数。
接下来的行，每行输入两个实数和，代表每道菜的原价是，折扣价是。
最后一行输入两个实数和，代表满元可以减元。


数据中所有实数的绝对值不超过1000。
```

##### 输出描述：

```
如果数据有误，则输出一行字符串"error"。
否则输出一个小数，小数点后保留2位即可。该小数代表顾客购买了全部菜各一份时，订单的总价格。
```

##### 示例1

输入例子：

```
2
10 5.5
10 6.5
15 3
```

输出例子：

```
12.00
```

例子说明：

```
虽然触发了满15元减3元，但使用折扣只需要花12元，低于使用满减的价格（20-3=17），因此最终系统会为客户推荐折扣价。
```

##### 示例2

输入例子：

```
2
10 5.5
10 6.5
20 10
```

输出例子：

```
10.00
```

例子说明：

```
触发满20元减10元即可。满减价优于折扣价。
```

##### 示例3

输入例子：

```
2
10 10.25
10 3.5
20 4.5
```

输出例子：

```
error
```

例子说明：

```
折扣价高于原价，数据错误。
```



##### 题解

```python
# 列举变量
n = int(input())	
v_list = []
origin = 0
discount = 0
for i in range(0,n):
    a = list(map(float, input().split()))
    if a[0]<a[1] or a[1]<=0 or a[0]<=0:
        print("error")
        quit()
    else:
        v_list.append(a)
x, y =map(float, input().split())
for i in range(len(v_list)):
    origin += v_list[i][0]
    discount += v_list[i][1]
if x>0 and y>0 and x>=y:
    if origin>=x:
        if origin-y<=discount:
            print("%.2f"%(origin-y))
        else:
            print("%.2f"%discount)
    else:
        print("%.2f"%discount)
else:
    print("error")
```



---



### 4.小美的排列询问

小美拿到了一个排列。她想知道在这个排列中，*x*和*y*是否是相邻的。你能帮帮她吗？

排列是指一个长度为*n*的数组，其中 1 到*n*每个元素恰好出现一次。

时间限制：C/C++ 1秒，其他语言2秒

空间限制：C/C++ 256M，其他语言512M

##### 输入描述：

```
第一行输入一个正整数，代表排列的长度。
第二行输入个正整数，代表排列的元素。
第三行输入两个正整数和，用空格隔开。



保证
```

##### 输出描述：

```
如果和在排列中相邻，则输出"Yes"。否则输出"No"。
```

##### 示例1

输入例子：

```
4
1 4 2 3
2 4
```

输出例子：

```
Yes
```

##### 示例2

输入例子：

```
5
3 4 5 1 2
3 2
```

输出例子：

```
No
```

##### 题解

```python
def create_arr(n):
    arr = list(map(int,input().split(' ')))
    return arr

def judge_next(x, y, arr):
    if x not in arr or y not in arr:
        return 'No'
    if x in arr or y in arr:
        if arr[arr.index(x)-1] == y or arr[arr.index(x)+1] == y:
            return 'Yes'
        # elif arr[arr.index(y)-1] == x or arr[arr.index(y)+1] == x:
        #     return 'Yes'
        else:
            return 'No'

n = int(input())
arr = create_arr(n)
x,y = map(int,input().split(' '))
print(judge_next(x, y, arr))
```

---

### 5.小美的排列构造

小美定义一个数组*a*的权值计算如下：

首先将*a*的每一对相邻两项求和，得到一个b*数组。那么b*数组的最大值减最小值即为*a*数组的权值。

例如，若a*=[2,1,3]，那么*b*=[3,4]，b*数组的极差是1。因此*a*数组的权值为1。

现在小美希望你能构造一个长度为*n*的排列，满足权值尽可能小。你能帮帮她吗？

排列是指一个长度为*n*的数组，其中 1 到*n*每个元素恰好出现一次。

```
时间限制：C/C++ 1秒，其他语言2秒

空间限制：C/C++ 256M，其他语言512M
```

##### 输入描述：

```
一个正整数，代表排列的长度。
2 ≤ n ≤ 200000
```

##### 输出描述：

```
一个合法的排列。如果有多解输出任意即可。
```

##### 示例1

输入例子：

```
3
```

输出例子：

```
2 1 3
```

例子说明：

```
这个数组的权值为 1。输出[2,3,1]等排列也是合法的。
```

##### 思路：

1. 排列组合求权值，n=3时有123、132、213、231、312、321共3！种排列法，其中要求权值最小为1的。

2. 此时看列表123：1+2=3，2+3=5；

   ​    再看列表213：2+1=3，1+3=4；此时还看不出什么，于是构造长度为4的列表；

3. list[1, 2, 3, 4]：只需满足最大-最小=极小，则（4+1）-（3+1）=1，原序列变为list[2, 3, 1, 4]。再构造一个len5列表观察一下；

4. list[1, 2, 3, 4, 5]：变为list[2, 3, 4, 1, 5]，发现权值为2，是否还存在更小权值呢？构造list[2, 3, 1, 4, 5]权值为5；

5. list[1, 2, 3, 4, 5, 6] -> weight = 10

   list[2, 3, 4, 5, 1, 6] -> weight = 3

   list[2, 3, 4, 1, 5, 6] -> weight = 6

6. 在此猜测，只要挪动1的位置，就可以使最小值极大，最大值极小，以此求出极小值。

7. 以n=5的列表举例：

   若list_a[1, 2, 3, 4, 5] -> list_b1[3, 5, 7, 9] -> 9 - 3 = 6

   交换list_a[i], list_a[i+1] = list_a[i+1], list_a[i]

   若list_a[2, 1, 3, 4, 5] -> list_b2[3, 4, 7, 9] -> 9 - 3 = 6

   ……（此时运行第一个程序发现题解错误）

   ```python
   # 改变1的位置
   def change_loc(_list):
       _list.pop(0)
       _list.insert(-1,1)
       return _list
   
   # 输入长度
   n = int(input())
   
   # 构建长度为n的列表a
   list_a = list(range(1,n+1))
   
   # 调用
   new_list_a = change_loc(list_a)
   
   for i in range(len(new_list_a)):
       print(new_list_a[i],end=" ")
   
   ```

   预期输出

   ```
   1 37 2 36 3 35 4 34 5 33 6 32 7 31 8 30 9 29 10 28 11 27 12 26 13 25 14 24 15 23 16 22 17 21 18 20 19
   ```

   实际输出

   ```
   2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 1 37 
   ```

   若list_a[1, 5, 2, 4, 3] -> list_b2[6, 7, 6, 7] -> 7 - 6 = 1

   我靠，还能这么搞

   此时犹如醍醐灌顶，茅塞顿开，但仔细一想暴力枚举出weight肯定是不行的，一共有n!种排列方式肯定会超时间，那么看实际输出：

   此时只要保持 (a[ i ] + a[ i + 1 ]) - (a[ i + 1 ] + a[ i + 2 ]) = 1 就可以了

   实际上也可以输出

   ```
   19 18 20 17 21 16 22 15 23 14 24 13 25 12 26 11 27 10 28 9 29 8 30 7 31 6 32 5 33 4 34 3 35 2 36 1 37 
   ```

   那么就可以根据结果来设计思路：

   1. 二分列表到位置n/2，获取list_a_1和list_a_2

      ```python
      n = 5
      list_a = [1, 2, 3, 4, 5]
      list_a_1 = list_a[:int(n/2)]	# 列表取一半位置
      list_a_2 = list(set(list_a)-set(list_a_1))	# 取列表补集
      
      out:
      [1, 2]
      [3, 4, 5]
      ```

   2. 倒序list_a_2

   3. 将list_a_2依次插入list_a_1（或者反过来插）

      ```python
      list_3 = []
      for i in range(max(len(list_a_1),len(list_a_2_reverse))):
          if len(list_a_1) - 1 >= i:
              list_3.append(list_a_1[i])
          if len(list_a_2_reverse) - 1 >= i:
              list_3.append(list_a_2_reverse[i])
      return list_3
      ```

      



##### 题解

```python
def resetlist(_list):
    list_a_1 = _list[:int(n / 2)]
    list_a_2 = list(set(_list) - set(list_a_1))
    list_a_2_reverse = list(reversed(list_a_2))
    list_3 = []
    for i in range(max(len(list_a_1),len(list_a_2_reverse))):
        if len(list_a_1) - 1 >= i:
            list_3.append(list_a_1[i])
        if len(list_a_2_reverse) - 1 >= i:
            list_3.append(list_a_2_reverse[i])
    return list_3

# 输入长度
n = int(input())

# 构建长度为n的列表a
list_a = list(range(1,n+1))

# 调用
_list = resetlist(list_a)
for i in _list:
    print(i, end=' ')
```

26/30 组用例通过

运行时间654ms

占用内存17636KB



### 6. 小美走公路

有一个环形的公路，上面共有�*n*站，现在给定了顺时针第�*i*站到第�+1*i*+1站之间的距离（特殊的，也给出了第�*n*站到第 1 站的距离）。小美想沿着公路第�*x*站走到第�*y*站，她想知道最短的距离是多少？

时间限制：C/C++ 1秒，其他语言2秒

空间限制：C/C++ 256M，其他语言512M

输入描述：

```
第一行输入一个正整数，代表站的数量。
第二行输入个正整数，前个数代表顺时针沿着公路走，站到第站之间的距离；最后一个正整数代表顺时针沿着公路走，第站到第 1 站的距离。
第三行输入两个正整数和，代表小美的出发地和目的地。
1 <= n <= 10^5
1 <= ai <= 10^9
1 <= x,y <= n
```

输出描述：

```
一个正整数，代表小美走的最短距离。
```

示例1

输入例子：

```
3
1 2 2
2 3
```

输出例子：

```
2
```

示例2

输入例子：

```
3
1 2 2
1 3
```

输出例子：

```
2
```